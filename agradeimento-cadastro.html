<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Robô de Lata 3D com Interação</title>
  <style>
    body { margin:0; background: #121212; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>

  // Cena, câmera e renderizador
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x20232a);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 6);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Luzes
  const ambientLight = new THREE.AmbientLight(0x404040, 2); 
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Material metálico para o robô
  const metalMaterial = new THREE.MeshStandardMaterial({
    color: 0x888888,
    metalness: 0.8,
    roughness: 0.2,
    emissive: 0x111111,
    clearcoat: 1,
    clearcoatRoughness: 0.1
  });

  // Cabeça do robô
  const headGeometry = new THREE.CylinderGeometry(1, 1, 1.5, 32, 1, false);
  const head = new THREE.Mesh(headGeometry, metalMaterial);
  head.position.y = 2.5;
  scene.add(head);

  // Olhos (esferas brilhantes)
  const eyeGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const eyeMaterialOn = new THREE.MeshStandardMaterial({color: 0x00fffc, emissive: 0x00fffc, metalness: 0.5, roughness: 0.1});
  const eyeMaterialOff = new THREE.MeshStandardMaterial({color: 0x002222, emissive: 0x000000, metalness: 0.5, roughness: 0.5});

  // Criar olho esquerdo e direito, como grupos para controlar movimento dos olhos
  const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterialOn);
  const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterialOn);
  leftEye.position.set(-0.4, 0, 0.9);
  rightEye.position.set(0.4, 0, 0.9);

  // Grupo dos olhos para movimentar dentro da cabeça
  const leftEyeGroup = new THREE.Group();
  leftEyeGroup.position.set(-0.4, 2.7, 0);
  leftEyeGroup.add(leftEye);
  scene.add(leftEyeGroup);

  const rightEyeGroup = new THREE.Group();
  rightEyeGroup.position.set(0.4, 2.7, 0);
  rightEyeGroup.add(rightEye);
  scene.add(rightEyeGroup);

  // Corpo
  const bodyGeometry = new THREE.CylinderGeometry(1.2, 1.2, 3, 32);
  const body = new THREE.Mesh(bodyGeometry, metalMaterial);
  body.position.y = 0.5;
  scene.add(body);

  // Braço esquerdo (para acenar) - tubo e junta
  const armMaterial = new THREE.MeshStandardMaterial({
    color: 0x555555,
    metalness: 0.9,
    roughness: 0.25
  });

  const upperArmGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 32);
  const jointGeometry = new THREE.SphereGeometry(0.35, 32, 32);

  const leftUpperArm = new THREE.Mesh(upperArmGeometry, armMaterial);
  const leftJoint = new THREE.Mesh(jointGeometry, armMaterial);

  // Posiciona braço e junta como grupo para facilitar rotação
  const leftArmGroup = new THREE.Group();
  leftUpperArm.position.set(0, -0.6, 0);
  leftUpperArm.rotation.z = Math.PI / 2;
  leftJoint.position.set(0, -1.2, 0);

  leftArmGroup.add(leftUpperArm);
  leftArmGroup.add(leftJoint);
  leftArmGroup.position.set(-1.6, 1.4, 0);
  scene.add(leftArmGroup);

  // Braço direito fixo
  const rightUpperArm = new THREE.Mesh(upperArmGeometry, armMaterial);
  const rightJoint = new THREE.Mesh(jointGeometry, armMaterial);
  rightUpperArm.position.set(1.6, 1.4, 0);
  rightUpperArm.rotation.z = Math.PI / 2;
  rightJoint.position.set(2.2, 1.4, 0);
  scene.add(rightUpperArm, rightJoint);

  // Pernas
  const legGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.8, 32);
  const leftLeg = new THREE.Mesh(legGeometry, metalMaterial);
  const rightLeg = new THREE.Mesh(legGeometry, metalMaterial);
  leftLeg.position.set(-0.6, -1.3, 0);
  rightLeg.position.set(0.6, -1.3, 0);
  scene.add(leftLeg, rightLeg);

  // Variáveis para controlar o movimento do braço acenando
  let armAngle = 0;
  let armDirection = 1;

  // Variáveis para posição do mouse (normalizado -1 a 1)
  let mouseX = 0;
  let mouseY = 0;

  // Evento para capturar posição do mouse
  window.addEventListener('mousemove', e => {
    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
    mouseY = - (e.clientY / window.innerHeight) * 2 + 1;
  });

  function animate() {
    requestAnimationFrame(animate);

    // Cabeça balança olhando para os lados suavemente
    head.rotation.y = Math.sin(Date.now() * 0.001) * 0.3;

    // Braço esquerdo acenando (rotaciona no eixo z)
    armAngle += 0.03 * armDirection;
    if (armAngle > 0.6) armDirection = -1;
    else if (armAngle < -0.4) armDirection = 1;
    leftArmGroup.rotation.z = armAngle;

    // Olhos seguindo o mouse dentro de limites [-0.15, 0.15]
    const eyeMaxMove = 0.15;
    leftEye.position.x = THREE.MathUtils.clamp(mouseX * eyeMaxMove, -eyeMaxMove, eyeMaxMove);
    leftEye.position.y = THREE.MathUtils.clamp(mouseY * eyeMaxMove, -eyeMaxMove, eyeMaxMove);
    rightEye.position.x = THREE.MathUtils.clamp(mouseX * eyeMaxMove, -eyeMaxMove, eyeMaxMove);
    rightEye.position.y = THREE.MathUtils.clamp(mouseY * eyeMaxMove, -eyeMaxMove, eyeMaxMove);

    // Piscar dos olhos rápido e aleatório
    const blink = (Math.sin(Date.now() * 0.02) > 0.95);
    leftEye.material = blink ? eyeMaterialOff : eyeMaterialOn;
    rightEye.material = blink ? eyeMaterialOff : eyeMaterialOn;

    renderer.render(scene, camera);
  }

  animate();

  // Responsividade
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
